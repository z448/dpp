#!/usr/bin/env perl

use 5.010;
use warnings;
use strict;

use JSON::PP;
use File::Find;
use File::Path;
use File::Copy;
use Term::ANSIColor;
use Config;
use FindBin;
use lib "$FindBin::Bin/../lib";
use open qw< :encoding(UTF-8) >;
use Cydia::Meta qw< control meta web >;

my( $base )= qw< ./cy >;
my @packlist_orig = ();

sub wanted {
    if(/\.packlist/){
        push @packlist_orig, "$File::Find::dir/$_";
    } 
}
find(\&wanted, $base);

print colored(['yellow'],"found packlists: ") . "\n";
for(@packlist_orig){
    print $_ . "\n";
}

# --define dir paths
my $installsitelib = $Config{installsitelib};
$installsitelib =~ s/^\///;
mkpath($installsitelib);
print colored(['yellow'], "installsitelib: ") . $installsitelib . "\n";

my $installbin = $Config{installbin};
$installbin =~ s/^\///;
mkpath($installbin);
print colored(['yellow'], "installbin: ") . $installbin . "\n";

my $installsiteman1dir = $Config{installsiteman1dir};
$installsiteman1dir =~ s/^\///;
mkpath($installsiteman1dir);
my $installman = $installsiteman1dir;
$installman =~ s/(.*\/)(man1)/$1/;
print colored(['yellow'], "installsiteman1dir: ") . $installsiteman1dir . "\n";

my $installsiteman3dir = $Config{installsiteman3dir};
$installsiteman3dir =~ s/^\///;
#$installsiteman3dir =~ s/(.*\/)(man3)/$1/;
mkpath($installsiteman3dir);
print colored(['yellow'], "installsiteman3dir: ") . $installsiteman3dir . "\n";

my $cytar_lib = $installsitelib;
$cytar_lib =~ s/(.*?)(\/.*)/$1/;

my $cytar_bin = $installbin;
$cytar_bin =~ s/(.*?)(\/.*)/$1/;

# todo: add xz/lzma compression option
my $move_pack = sub {
    my $repo = shift;
    my $cargo = <<"_CYDIA";
    cat .www >> ../.stash/cydia/.www
    mv *.deb ~/.dpp/.stash/cydia/deb
    cd $ENV{CYSTASH}/cydia
    cysp
    tar -zcvf cydia.tgz Packages.gz deb .www
    scp cydia.tgz $repo:~/www/cydia
_CYDIA
    my $transfer = sub {
        system("$cargo");
    }; $transfer->();
};

my $make_pack = sub { 
    my $pm = shift;
    my $ar = <<"_DEB";
    cd $pm; tar -xvf data.tar.gz;
    rm data.tar.gz;
    tar czf ../data.tar.gz $installsitelib $installbin;
    cd DEBIAN/;
    tar czf ../../control.tar.gz *;
    cd ../..;
    echo 2.0 > debian-binary;
    arfp r $pm.deb debian-binary control.tar.gz data.tar.gz;
    mv $pm.deb ~/.dpp/.stash/deb;
    rm -rf debian-binary control.tar.gz data.tar.gz DEBIAN;
_DEB
    my $package = sub {
        my $packer = shift;
        my $status  = system($packer);
    }; 
    my $status = $package->($ar);
};

my $check_pack = sub {
    my $p = shift;
    my $cpanm = {};

    $cpanm->{lib} = "$base/lib/perl5";
    $cpanm->{bin} = "$base/bin";
    $cpanm->{man} = "$base/man";

    system("mv $cpanm->{lib}/* $installsitelib");
    system("mv $cpanm->{bin}/* $installbin");
    system("mv $cpanm->{man}/* $installman");
    print "\n";

    for my $pack( @$p ){
            print "\n\n";
         
            # -- list content of received packlist
            print colored(['yellow'],"packlist path: ") . $pack->{path} . "\n";
            print colored(['yellow'],"pkg: ") . $pack->{pkg} . "\n";
            print colored(['yellow'],"packlist content: ") . "\n";
            for(@{$pack->{packlist}}){ say $_ }
    
            my $make_path = mkpath("$pack->{pkg}/DEBIAN");

            my $fh = undef;
            my $fn = "$ENV{HOME}/.dpp/build/$pack->{pkg}/DEBIAN/control";
            open( $fh, ">", $fn ) || die "cant open $fn";
            print $fh control("$pack->{module}") . "\n";
            close $fh;
            print "\n" . colored(['green'],"created control file for: ") . $pack->{module} . "\n";
            say control($pack->{module});

            my $installsitelib_dir = $installsitelib;
            $installsitelib_dir =~ s/(.*?)(\/.*)/$1/;
            my( $dpp_packlist ) = ();

            find( sub{ if( /\.packlist/ ){ 
                        $dpp_packlist = "$File::Find::dir/$_";
                        print colored(['yellow'],"removing") . $pack->{path} . "\n";
                        unlink($pack->{path});
            }}, $installsitelib_dir );
                
            
    #print colored(['yellow'], "writing files to $pack->{pkg}/.packlist") . "$File::Find::dir/$_" . "\n";
            find( sub{ unless(/perllocal\.pod/){
                        if( -f $_ ){ 
                            open( my $findh, ">>", "$ENV{DPP}/build/$pack->{pkg}/.packlist" ) || die "$!: cant open $pack->{pkg}/.packlist";
                            print colored(['yellow'], "writing file: ") . "$File::Find::dir/$_" . "\n";
                            say $findh "$File::Find::dir/$_";
                        } else {
                        print colored(['yellow'], "skipping dir: ") . "$File::Find::dir/$_" . "\n";
                        open(my $fh,">>", "$ENV{DPP}/build/.remove") || die "cant open $!";
                        close $fh;
                    }}}, ($installsitelib, $installbin ));
        #}}}, ($installsitelib, $installbin, $installman ));

            #create new data.pack using new packlist
            my $datapack = sub {
                my $tar = system("tar cz -T $pack->{pkg}/.packlist -f $pack->{pkg}/data.tar.gz");
            }; $datapack->();
            print colored(['yellow'], "using: ") . "$pack->{pkg}/.packlist for data.tar.gz" . "\n";

            #call make_pack, build deb
            unless( $make_pack->($pack->{pkg}) ){
                print colored(['green'], "$pack->{pkg} : ok") . "\n";
                web($pack->{module}) and print "web: $pack->{module}" . " ok\n";
            }

            my $cleanup = sub {
                open(my $fh, "<", "$ENV{DPP}/build/$pack->{pkg}/.packlist");
                while(<$fh>){
                    unlink $_;
                }; close $fh;
                open($fh,"<", "$ENV{DPP}/build/.remove") || die "cant open $!";
                while(<$fh>){
                    unlink $_;
                }; close $fh;
                unlink "$ENV{DPP}/build/.remove";
            }; $cleanup->();
    }
};

my $list_pack = sub {
    my $p = shift;
    my @pack = ();
    my( @meta )= ();
 
    print "\n\n" . colored(['yellow'],"received packlists: ") . "\n";
    print $_ . "\n" for (@$p);

    for my $path( @$p ){
        chomp(my $module = $path);

        # make module($pm) name from packlist($path)
        $module =~ s/(auto.*?\/)(.*?)(\/\.packlist)/$2/;
        $module = $2;
        $module =~ s/\//\:\:/g;
        print colored(['yellow'],"module is: ") . $module . "\n\n";

        print colored(['yellow'],"packlist content is:") . "\n";
        open( my $fh, "<", $path );
        while( <$fh>){
            chomp;

            #content(file paths) of current packlist
            my $home = qr/$ENV{HOME}/;
            if( /\/cy\// ){
                if(/$home/){

                    s/(.*?)(\/cy\/)(.*)/$3/;
                    push @pack, $_;

                    print colored(['yellow'],"adding: ") . "$_ ";

                }
            } else {
                print colored(['yellow'],"skipping: ") . "$_ ";;
            }
            print "\n";
        }
        
        my $meta = meta($module);
        my $pkg = $meta->{pkg};

        my $pack = {
            pkg        =>  $pkg,
            module     =>  $module,
            path       =>  $path,
            packlist   =>  \@pack,
        };         
    push @meta, $pack;
    close $fh;
    }
    $check_pack->( \@meta );
};

$list_pack->(\@packlist_orig);

my $make_html = sub {
    my $json_file = "$ENV{DPP}/assets/html/index.json";
    my $html_file= "$ENV{DPP}/assets/html/index.html";

    open(my $fh,"<",$json_file) || die "cant open $json_file: $!";
    my $index_json = <$fh>;
    my $index_hash = decode_json $index_json;
    close $fh;
         
    open($fh,">",$html_file) || die "cant open $html_file: $!";
    for( @{$index_hash->{head}} ){ print $fh $_ }
    for( @{$index_hash->{style}} ){ print $fh $_ }
    for( @{$index_hash->{body}} ){ print $fh $_ }
    for( @{$index_hash->{foot}} ){ print $fh $_ }

};  $make_html->();

rmdir "$ENV{DPP}/build/cy";

__DATA__
1. xz/lmza on telesphoero needs fix4 
tar -cf - usr | xz -9 -c - > ../data.tar.xz
tar -cf - usr | lzma -9 -c - > ../data.tar.lmzm
