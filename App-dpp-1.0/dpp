#!/usr/bin/env perl

use 5.010;
use warnings;
use strict;

use Term::ANSIColor;
use Getopt::Std;
use App::Dpp qw< control meta web init cleanup >;
use Data::Dumper;
use JSON::PP;
use Config;
use File::Find;
use File::Path;
use open qw< :encoding(UTF-8) >;

my $options = {};

getopts('d:', $options);
init();

# takes path to site_perl dir; returns array ref with all .packlist paths
sub find_packlist {
    my $siteperl_path = shift;
    my @packlist_file = ();

    find( sub {
            if(/\.packlist/){
                push @packlist_file, "$File::Find::dir/$_";
            }
        }, $siteperl_path );
    return \@packlist_file;
}

# takes array ref containing .packlist paths;
# makes hash ref containing { pkg => package name, module => module name, path => .packlist path, packlist => .packlist contents, control => control file }
sub parse_packlist {
    my $packlist_path = shift;
    my( @meta )= ();
 
    for my $path( @$packlist_path ){
        my @pack = ();
        chomp($path);
        my $module = $path;

        # make module($pm) name from packlist($path)
        $module =~ s/(auto.*?\/)(.*?)(\/\.packlist)/$2/;
        $module = $2;
        $module =~ s/\//\:\:/g;
        open( my $fh, "<", $path );
        while( <$fh>){ chomp and push @pack, $_ }
        
        my $meta = meta($module);
        my $pkg = $meta->{pkg};
        my $pack = {
            pkg        =>  $pkg,
            module     =>  $module,
            path       =>  $path,
            packlist   =>  \@pack,
            control    =>  control($module),
        };         
        push @{$pack->{packlist}}, $pack->{$path};

#    push @meta, $pack;
    close $fh;
    print "packing $pack->{module}\t" . ' <--> ' . "$pack->{pkg}\t\n";
    pack_packlist($pack);
    }
};

sub pack_packlist {
    my $meta_pack = shift;
    my $build_path = init('build');
    my $pack_path = $build_path . "/$meta_pack->{pkg}";
    my $deb_path = init('deb');
    mkpath($pack_path);

    # tar packlist content into data.tar.gz
    system("tar cz -T $meta_pack->{path} -f $build_path/data.tar.gz && cd $build_path && tar -xvf data.tar.gz && rm -rf data.tar.gz && rm -rf $pack_path  && tar -zcvf data.tar.gz * && mv data.tar.gz .. && rm -rf * && mv ../data.tar.gz . && cd -");
    mkpath("$pack_path/DEBIAN");

    # write control file
    open(my $fh,">", "$pack_path/DEBIAN/control") || die "cant open $pack_path/DEBIAN/control: $!";
    print $fh $meta_pack->{control};
    close $fh;

    # make .deb
    my $packer = <<"_DEB";

    cd $pack_path/DEBIAN;
    tar czf ../../control.tar.gz *;
    cd ../..;
    echo 2.0 > debian-binary;
    ar r $meta_pack->{pkg}.deb debian-binary control.tar.gz data.tar.gz;
    mv $meta_pack->{pkg}.deb $deb_path;
    rm -rf $meta_pack->{pkg};
    rm -rf debian-binary control.tar.gz data.tar.gz DEBIAN;
_DEB
    system("$packer");
    eval { web("$meta_pack->{module}") };
    make_html();
    #die;
}

sub make_html {
    my $json_file = init('assets') . "/index.json";
    my $html_file= init('assets') . "/index.html";

    open(my $fh,"<",$json_file) || die "cant open $json_file: $!";
    my $index_json = <$fh>;
    my $index_hash = decode_json $index_json;
    close $fh;
         
    open($fh,">",$html_file) || die "cant open $html_file: $!";
    for( @{$index_hash->{head}} ){ print $fh $_ }
    for( @{$index_hash->{style}} ){ print $fh $_ }
    for( @{$index_hash->{body}} ){ print $fh $_ }
    for( @{$index_hash->{foot}} ){ print $fh $_ }

}






die "add path to perl modules dir" unless $ARGV[0];
parse_packlist(find_packlist("$ARGV[0]"));


